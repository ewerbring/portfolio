{"ast":null,"code":"import PropTypes from 'prop-types';\nimport React, { PureComponent, Component } from 'react';\nimport styled from 'styled-components';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nvar getLength = function getLength(x, y) {\n  return Math.sqrt(x * x + y * y);\n};\n\nvar getAngle = function getAngle(_ref, _ref2) {\n  var x1 = _ref.x,\n      y1 = _ref.y;\n  var x2 = _ref2.x,\n      y2 = _ref2.y;\n  var dot = x1 * x2 + y1 * y2;\n  var det = x1 * y2 - y1 * x2;\n  var angle = Math.atan2(det, dot) / Math.PI * 180;\n  return (angle + 360) % 360;\n};\n\nvar degToRadian = function degToRadian(deg) {\n  return deg * Math.PI / 180;\n};\n\nvar cos = function cos(deg) {\n  return Math.cos(degToRadian(deg));\n};\n\nvar sin = function sin(deg) {\n  return Math.sin(degToRadian(deg));\n};\n\nvar setWidthAndDeltaW = function setWidthAndDeltaW(width, deltaW, minWidth) {\n  var expectedWidth = width + deltaW;\n\n  if (expectedWidth > minWidth) {\n    width = expectedWidth;\n  } else {\n    deltaW = minWidth - width;\n    width = minWidth;\n  }\n\n  return {\n    width: width,\n    deltaW: deltaW\n  };\n};\n\nvar setHeightAndDeltaH = function setHeightAndDeltaH(height, deltaH, minHeight) {\n  var expectedHeight = height + deltaH;\n\n  if (expectedHeight > minHeight) {\n    height = expectedHeight;\n  } else {\n    deltaH = minHeight - height;\n    height = minHeight;\n  }\n\n  return {\n    height: height,\n    deltaH: deltaH\n  };\n};\n\nvar getNewStyle = function getNewStyle(type, rect, deltaW, deltaH, ratio, minWidth, minHeight) {\n  var width = rect.width,\n      height = rect.height,\n      centerX = rect.centerX,\n      centerY = rect.centerY,\n      rotateAngle = rect.rotateAngle;\n  var widthFlag = width < 0 ? -1 : 1;\n  var heightFlag = height < 0 ? -1 : 1;\n  width = Math.abs(width);\n  height = Math.abs(height);\n\n  switch (type) {\n    case 'r':\n      {\n        var widthAndDeltaW = setWidthAndDeltaW(width, deltaW, minWidth);\n        width = widthAndDeltaW.width;\n        deltaW = widthAndDeltaW.deltaW;\n\n        if (ratio) {\n          deltaH = deltaW / ratio;\n          height = width / ratio; // 左上角固定\n\n          centerX += deltaW / 2 * cos(rotateAngle) - deltaH / 2 * sin(rotateAngle);\n          centerY += deltaW / 2 * sin(rotateAngle) + deltaH / 2 * cos(rotateAngle);\n        } else {\n          // 左边固定\n          centerX += deltaW / 2 * cos(rotateAngle);\n          centerY += deltaW / 2 * sin(rotateAngle);\n        }\n\n        break;\n      }\n\n    case 'tr':\n      {\n        deltaH = -deltaH;\n\n        var _widthAndDeltaW = setWidthAndDeltaW(width, deltaW, minWidth);\n\n        width = _widthAndDeltaW.width;\n        deltaW = _widthAndDeltaW.deltaW;\n        var heightAndDeltaH = setHeightAndDeltaH(height, deltaH, minHeight);\n        height = heightAndDeltaH.height;\n        deltaH = heightAndDeltaH.deltaH;\n\n        if (ratio) {\n          deltaW = deltaH * ratio;\n          width = height * ratio;\n        }\n\n        centerX += deltaW / 2 * cos(rotateAngle) + deltaH / 2 * sin(rotateAngle);\n        centerY += deltaW / 2 * sin(rotateAngle) - deltaH / 2 * cos(rotateAngle);\n        break;\n      }\n\n    case 'br':\n      {\n        var _widthAndDeltaW2 = setWidthAndDeltaW(width, deltaW, minWidth);\n\n        width = _widthAndDeltaW2.width;\n        deltaW = _widthAndDeltaW2.deltaW;\n\n        var _heightAndDeltaH = setHeightAndDeltaH(height, deltaH, minHeight);\n\n        height = _heightAndDeltaH.height;\n        deltaH = _heightAndDeltaH.deltaH;\n\n        if (ratio) {\n          deltaW = deltaH * ratio;\n          width = height * ratio;\n        }\n\n        centerX += deltaW / 2 * cos(rotateAngle) - deltaH / 2 * sin(rotateAngle);\n        centerY += deltaW / 2 * sin(rotateAngle) + deltaH / 2 * cos(rotateAngle);\n        break;\n      }\n\n    case 'b':\n      {\n        var _heightAndDeltaH2 = setHeightAndDeltaH(height, deltaH, minHeight);\n\n        height = _heightAndDeltaH2.height;\n        deltaH = _heightAndDeltaH2.deltaH;\n\n        if (ratio) {\n          deltaW = deltaH * ratio;\n          width = height * ratio; // 左上角固定\n\n          centerX += deltaW / 2 * cos(rotateAngle) - deltaH / 2 * sin(rotateAngle);\n          centerY += deltaW / 2 * sin(rotateAngle) + deltaH / 2 * cos(rotateAngle);\n        } else {\n          // 上边固定\n          centerX -= deltaH / 2 * sin(rotateAngle);\n          centerY += deltaH / 2 * cos(rotateAngle);\n        }\n\n        break;\n      }\n\n    case 'bl':\n      {\n        deltaW = -deltaW;\n\n        var _widthAndDeltaW3 = setWidthAndDeltaW(width, deltaW, minWidth);\n\n        width = _widthAndDeltaW3.width;\n        deltaW = _widthAndDeltaW3.deltaW;\n\n        var _heightAndDeltaH3 = setHeightAndDeltaH(height, deltaH, minHeight);\n\n        height = _heightAndDeltaH3.height;\n        deltaH = _heightAndDeltaH3.deltaH;\n\n        if (ratio) {\n          height = width / ratio;\n          deltaH = deltaW / ratio;\n        }\n\n        centerX -= deltaW / 2 * cos(rotateAngle) + deltaH / 2 * sin(rotateAngle);\n        centerY -= deltaW / 2 * sin(rotateAngle) - deltaH / 2 * cos(rotateAngle);\n        break;\n      }\n\n    case 'l':\n      {\n        deltaW = -deltaW;\n\n        var _widthAndDeltaW4 = setWidthAndDeltaW(width, deltaW, minWidth);\n\n        width = _widthAndDeltaW4.width;\n        deltaW = _widthAndDeltaW4.deltaW;\n\n        if (ratio) {\n          height = width / ratio;\n          deltaH = deltaW / ratio; // 右上角固定\n\n          centerX -= deltaW / 2 * cos(rotateAngle) + deltaH / 2 * sin(rotateAngle);\n          centerY -= deltaW / 2 * sin(rotateAngle) - deltaH / 2 * cos(rotateAngle);\n        } else {\n          // 右边固定\n          centerX -= deltaW / 2 * cos(rotateAngle);\n          centerY -= deltaW / 2 * sin(rotateAngle);\n        }\n\n        break;\n      }\n\n    case 'tl':\n      {\n        deltaW = -deltaW;\n        deltaH = -deltaH;\n\n        var _widthAndDeltaW5 = setWidthAndDeltaW(width, deltaW, minWidth);\n\n        width = _widthAndDeltaW5.width;\n        deltaW = _widthAndDeltaW5.deltaW;\n\n        var _heightAndDeltaH4 = setHeightAndDeltaH(height, deltaH, minHeight);\n\n        height = _heightAndDeltaH4.height;\n        deltaH = _heightAndDeltaH4.deltaH;\n\n        if (ratio) {\n          width = height * ratio;\n          deltaW = deltaH * ratio;\n        }\n\n        centerX -= deltaW / 2 * cos(rotateAngle) - deltaH / 2 * sin(rotateAngle);\n        centerY -= deltaW / 2 * sin(rotateAngle) + deltaH / 2 * cos(rotateAngle);\n        break;\n      }\n\n    case 't':\n      {\n        deltaH = -deltaH;\n\n        var _heightAndDeltaH5 = setHeightAndDeltaH(height, deltaH, minHeight);\n\n        height = _heightAndDeltaH5.height;\n        deltaH = _heightAndDeltaH5.deltaH;\n\n        if (ratio) {\n          width = height * ratio;\n          deltaW = deltaH * ratio; // 左下角固定\n\n          centerX += deltaW / 2 * cos(rotateAngle) + deltaH / 2 * sin(rotateAngle);\n          centerY += deltaW / 2 * sin(rotateAngle) - deltaH / 2 * cos(rotateAngle);\n        } else {\n          centerX += deltaH / 2 * sin(rotateAngle);\n          centerY -= deltaH / 2 * cos(rotateAngle);\n        }\n\n        break;\n      }\n  }\n\n  return {\n    position: {\n      centerX: centerX,\n      centerY: centerY\n    },\n    size: {\n      width: width * widthFlag,\n      height: height * heightFlag\n    }\n  };\n};\n\nvar cursorStartMap = {\n  n: 0,\n  ne: 1,\n  e: 2,\n  se: 3,\n  s: 4,\n  sw: 5,\n  w: 6,\n  nw: 7\n};\nvar cursorDirectionArray = ['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'];\nvar cursorMap = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 2,\n  4: 3,\n  5: 4,\n  6: 4,\n  7: 5,\n  8: 6,\n  9: 6,\n  10: 7,\n  11: 8\n};\n\nvar getCursor = function getCursor(rotateAngle, d) {\n  var increment = cursorMap[Math.floor(rotateAngle / 30)];\n  var index = cursorStartMap[d];\n  var newIndex = (index + increment) % 8;\n  return cursorDirectionArray[newIndex];\n};\n\nvar centerToTL = function centerToTL(_ref3) {\n  var centerX = _ref3.centerX,\n      centerY = _ref3.centerY,\n      width = _ref3.width,\n      height = _ref3.height,\n      rotateAngle = _ref3.rotateAngle;\n  return {\n    top: centerY - height / 2,\n    left: centerX - width / 2,\n    width: width,\n    height: height,\n    rotateAngle: rotateAngle\n  };\n};\n\nvar tLToCenter = function tLToCenter(_ref4) {\n  var top = _ref4.top,\n      left = _ref4.left,\n      width = _ref4.width,\n      height = _ref4.height,\n      rotateAngle = _ref4.rotateAngle;\n  return {\n    position: {\n      centerX: left + width / 2,\n      centerY: top + height / 2\n    },\n    size: {\n      width: width,\n      height: height\n    },\n    transform: {\n      rotateAngle: rotateAngle\n    }\n  };\n};\n\nvar StyledRect = styled.div.withConfig({\n  displayName: \"StyledRect\",\n  componentId: \"sc-1uso172-0\"\n})([\"position:absolute;border:1px solid #eb5648;.square{position:absolute;width:7px;height:7px;background:white;border:1px solid #eb5648;border-radius:1px;}.resizable-handler{position:absolute;width:14px;height:14px;cursor:pointer;z-index:1;&.tl,&.t,&.tr{top:-7px;}&.tl,&.l,&.bl{left:-7px;}&.bl,&.b,&.br{bottom:-7px;}&.br,&.r,&.tr{right:-7px;}&.l,&.r{margin-top:-7px;}&.t,&.b{margin-left:-7px;}}.rotate{position:absolute;cursor:pointer;left:50%;top:-26px;transform:translateX(-50%);& i{font-size:18px;display:inline-block;width:1em;height:1em;background-size:1em 1em;background-repeat:no-repeat;background-position:center center;background-image:url(\\\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJNOC4zIDUuNEw4IC40bDMuMiAyLjEgMS43IDF6Ii8+PG1hc2sgaWQ9ImIiIHg9IjAiIHk9IjAiIHdpZHRoPSI0LjkiIGhlaWdodD0iNC45IiBmaWxsPSIjZmZmIj48dXNlIHhsaW5rOmhyZWY9IiNhIi8+PC9tYXNrPjwvZGVmcz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxIDEpIiBzdHJva2U9IiNGNTVENTQiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+PHBhdGggZD0iTTExIDkuMkE2IDYgMCAwIDEgMCA2YTYgNiAwIDAgMSAxMC43LTMuOCIvPjx1c2UgbWFzaz0idXJsKCNiKSIgc3Ryb2tlLXdpZHRoPSIyIiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSAyMSAwKSIgeGxpbms6aHJlZj0iI2EiLz48L2c+PC9zdmc+Cg==\\\");}}.t,.tl,.tr{top:-3px;}.b,.bl,.br{bottom:-3px;}.r,.tr,.br{right:-3px;}.tl,.l,.bl{left:-3px;}.l,.r{top:50%;margin-top:-3px;}.t,.b{left:50%;margin-left:-3px;}\"]);\nvar zoomableMap = {\n  'n': 't',\n  's': 'b',\n  'e': 'r',\n  'w': 'l',\n  'ne': 'tr',\n  'nw': 'tl',\n  'se': 'br',\n  'sw': 'bl'\n};\n\nvar Rect =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(Rect, _PureComponent);\n\n  function Rect() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Rect);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Rect)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"setElementRef\", function (ref) {\n      _this.$element = ref;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"startDrag\", function (e) {\n      var startX = e.clientX,\n          startY = e.clientY;\n      _this.props.onDragStart && _this.props.onDragStart();\n      _this._isMouseDown = true;\n\n      var onMove = function onMove(e) {\n        if (!_this._isMouseDown) return; // patch: fix windows press win key during mouseup issue\n\n        e.stopImmediatePropagation();\n        var clientX = e.clientX,\n            clientY = e.clientY;\n        var deltaX = clientX - startX;\n        var deltaY = clientY - startY;\n\n        _this.props.onDrag(deltaX, deltaY);\n\n        startX = clientX;\n        startY = clientY;\n      };\n\n      var onUp = function onUp() {\n        document.removeEventListener('mousemove', onMove);\n        document.removeEventListener('mouseup', onUp);\n        if (!_this._isMouseDown) return;\n        _this._isMouseDown = false;\n        _this.props.onDragEnd && _this.props.onDragEnd();\n      };\n\n      document.addEventListener('mousemove', onMove);\n      document.addEventListener('mouseup', onUp);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"startRotate\", function (e) {\n      if (e.button !== 0) return;\n      var clientX = e.clientX,\n          clientY = e.clientY;\n      var startAngle = _this.props.styles.transform.rotateAngle;\n\n      var rect = _this.$element.getBoundingClientRect();\n\n      var center = {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2\n      };\n      var startVector = {\n        x: clientX - center.x,\n        y: clientY - center.y\n      };\n      _this.props.onRotateStart && _this.props.onRotateStart();\n      _this._isMouseDown = true;\n\n      var onMove = function onMove(e) {\n        if (!_this._isMouseDown) return; // patch: fix windows press win key during mouseup issue\n\n        e.stopImmediatePropagation();\n        var clientX = e.clientX,\n            clientY = e.clientY;\n        var rotateVector = {\n          x: clientX - center.x,\n          y: clientY - center.y\n        };\n        var angle = getAngle(startVector, rotateVector);\n\n        _this.props.onRotate(angle, startAngle);\n      };\n\n      var onUp = function onUp() {\n        document.removeEventListener('mousemove', onMove);\n        document.removeEventListener('mouseup', onUp);\n        if (!_this._isMouseDown) return;\n        _this._isMouseDown = false;\n        _this.props.onRotateEnd && _this.props.onRotateEnd();\n      };\n\n      document.addEventListener('mousemove', onMove);\n      document.addEventListener('mouseup', onUp);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"startResize\", function (e, cursor) {\n      if (e.button !== 0) return;\n      document.body.style.cursor = cursor;\n      var _this$props$styles = _this.props.styles,\n          _this$props$styles$po = _this$props$styles.position,\n          centerX = _this$props$styles$po.centerX,\n          centerY = _this$props$styles$po.centerY,\n          _this$props$styles$si = _this$props$styles.size,\n          width = _this$props$styles$si.width,\n          height = _this$props$styles$si.height,\n          rotateAngle = _this$props$styles.transform.rotateAngle;\n      var startX = e.clientX,\n          startY = e.clientY;\n      var rect = {\n        width: width,\n        height: height,\n        centerX: centerX,\n        centerY: centerY,\n        rotateAngle: rotateAngle\n      };\n      var type = e.target.getAttribute('class').split(' ')[0];\n      _this.props.onResizeStart && _this.props.onResizeStart();\n      _this._isMouseDown = true;\n\n      var onMove = function onMove(e) {\n        if (!_this._isMouseDown) return; // patch: fix windows press win key during mouseup issue\n\n        e.stopImmediatePropagation();\n        var clientX = e.clientX,\n            clientY = e.clientY;\n        var deltaX = clientX - startX;\n        var deltaY = clientY - startY;\n        var alpha = Math.atan2(deltaY, deltaX);\n        var deltaL = getLength(deltaX, deltaY);\n        var isShiftKey = e.shiftKey;\n\n        _this.props.onResize(deltaL, alpha, rect, type, isShiftKey);\n      };\n\n      var onUp = function onUp() {\n        document.body.style.cursor = 'auto';\n        document.removeEventListener('mousemove', onMove);\n        document.removeEventListener('mouseup', onUp);\n        if (!_this._isMouseDown) return;\n        _this._isMouseDown = false;\n        _this.props.onResizeEnd && _this.props.onResizeEnd();\n      };\n\n      document.addEventListener('mousemove', onMove);\n      document.addEventListener('mouseup', onUp);\n    });\n\n    return _this;\n  }\n\n  _createClass(Rect, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          _this$props$styles2 = _this$props.styles,\n          _this$props$styles2$p = _this$props$styles2.position,\n          centerX = _this$props$styles2$p.centerX,\n          centerY = _this$props$styles2$p.centerY,\n          _this$props$styles2$s = _this$props$styles2.size,\n          width = _this$props$styles2$s.width,\n          height = _this$props$styles2$s.height,\n          rotateAngle = _this$props$styles2.transform.rotateAngle,\n          zoomable = _this$props.zoomable,\n          rotatable = _this$props.rotatable,\n          parentRotateAngle = _this$props.parentRotateAngle;\n      var style = {\n        width: Math.abs(width),\n        height: Math.abs(height),\n        transform: \"rotate(\".concat(rotateAngle, \"deg)\"),\n        left: centerX - Math.abs(width) / 2,\n        top: centerY - Math.abs(height) / 2\n      };\n      var direction = zoomable.split(',').map(function (d) {\n        return d.trim();\n      }).filter(function (d) {\n        return d;\n      }); // TODO: may be speed up\n\n      return React.createElement(StyledRect, {\n        ref: this.setElementRef,\n        onMouseDown: this.startDrag,\n        className: \"rect single-resizer\",\n        style: style\n      }, rotatable && React.createElement(\"div\", {\n        className: \"rotate\",\n        onMouseDown: this.startRotate\n      }, React.createElement(\"i\", null)), direction.map(function (d) {\n        var cursor = \"\".concat(getCursor(rotateAngle + parentRotateAngle, d), \"-resize\");\n        return React.createElement(\"div\", {\n          key: d,\n          style: {\n            cursor: cursor\n          },\n          className: \"\".concat(zoomableMap[d], \" resizable-handler\"),\n          onMouseDown: function onMouseDown(e) {\n            return _this2.startResize(e, cursor);\n          }\n        });\n      }), direction.map(function (d) {\n        return React.createElement(\"div\", {\n          key: d,\n          className: \"\".concat(zoomableMap[d], \" square\")\n        });\n      }));\n    }\n  }]);\n\n  return Rect;\n}(PureComponent);\n\n_defineProperty(Rect, \"propTypes\", {\n  styles: PropTypes.object,\n  zoomable: PropTypes.string,\n  rotatable: PropTypes.bool,\n  onResizeStart: PropTypes.func,\n  onResize: PropTypes.func,\n  onResizeEnd: PropTypes.func,\n  onRotateStart: PropTypes.func,\n  onRotate: PropTypes.func,\n  onRotateEnd: PropTypes.func,\n  onDragStart: PropTypes.func,\n  onDrag: PropTypes.func,\n  onDragEnd: PropTypes.func,\n  parentRotateAngle: PropTypes.number\n});\n\nvar ResizableRect =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(ResizableRect, _Component);\n\n  function ResizableRect() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, ResizableRect);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ResizableRect)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleRotate\", function (angle, startAngle) {\n      if (!_this.props.onRotate) return;\n      var rotateAngle = Math.round(startAngle + angle);\n\n      if (rotateAngle >= 360) {\n        rotateAngle -= 360;\n      } else if (rotateAngle < 0) {\n        rotateAngle += 360;\n      }\n\n      if (rotateAngle > 356 || rotateAngle < 4) {\n        rotateAngle = 0;\n      } else if (rotateAngle > 86 && rotateAngle < 94) {\n        rotateAngle = 90;\n      } else if (rotateAngle > 176 && rotateAngle < 184) {\n        rotateAngle = 180;\n      } else if (rotateAngle > 266 && rotateAngle < 274) {\n        rotateAngle = 270;\n      }\n\n      _this.props.onRotate(rotateAngle);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleResize\", function (length, alpha, rect, type, isShiftKey) {\n      if (!_this.props.onResize) return;\n      var _this$props = _this.props,\n          rotateAngle = _this$props.rotateAngle,\n          aspectRatio = _this$props.aspectRatio,\n          minWidth = _this$props.minWidth,\n          minHeight = _this$props.minHeight,\n          parentRotateAngle = _this$props.parentRotateAngle;\n      var beta = alpha - degToRadian(rotateAngle + parentRotateAngle);\n      var deltaW = length * Math.cos(beta);\n      var deltaH = length * Math.sin(beta);\n      var ratio = isShiftKey && !aspectRatio ? rect.width / rect.height : aspectRatio;\n\n      var _getNewStyle = getNewStyle(type, _objectSpread({}, rect, {\n        rotateAngle: rotateAngle\n      }), deltaW, deltaH, ratio, minWidth, minHeight),\n          _getNewStyle$position = _getNewStyle.position,\n          centerX = _getNewStyle$position.centerX,\n          centerY = _getNewStyle$position.centerY,\n          _getNewStyle$size = _getNewStyle.size,\n          width = _getNewStyle$size.width,\n          height = _getNewStyle$size.height;\n\n      _this.props.onResize(centerToTL({\n        centerX: centerX,\n        centerY: centerY,\n        width: width,\n        height: height,\n        rotateAngle: rotateAngle\n      }), isShiftKey, type);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleDrag\", function (deltaX, deltaY) {\n      _this.props.onDrag && _this.props.onDrag(deltaX, deltaY);\n    });\n\n    return _this;\n  }\n\n  _createClass(ResizableRect, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          top = _this$props2.top,\n          left = _this$props2.left,\n          width = _this$props2.width,\n          height = _this$props2.height,\n          rotateAngle = _this$props2.rotateAngle,\n          parentRotateAngle = _this$props2.parentRotateAngle,\n          zoomable = _this$props2.zoomable,\n          rotatable = _this$props2.rotatable,\n          onRotate = _this$props2.onRotate,\n          onResizeStart = _this$props2.onResizeStart,\n          onResizeEnd = _this$props2.onResizeEnd,\n          onRotateStart = _this$props2.onRotateStart,\n          onRotateEnd = _this$props2.onRotateEnd,\n          onDragStart = _this$props2.onDragStart,\n          onDragEnd = _this$props2.onDragEnd;\n      var styles = tLToCenter({\n        top: top,\n        left: left,\n        width: width,\n        height: height,\n        rotateAngle: rotateAngle\n      });\n      return React.createElement(Rect, {\n        styles: styles,\n        zoomable: zoomable,\n        rotatable: Boolean(rotatable && onRotate),\n        parentRotateAngle: parentRotateAngle,\n        onResizeStart: onResizeStart,\n        onResize: this.handleResize,\n        onResizeEnd: onResizeEnd,\n        onRotateStart: onRotateStart,\n        onRotate: this.handleRotate,\n        onRotateEnd: onRotateEnd,\n        onDragStart: onDragStart,\n        onDrag: this.handleDrag,\n        onDragEnd: onDragEnd\n      });\n    }\n  }]);\n\n  return ResizableRect;\n}(Component);\n\n_defineProperty(ResizableRect, \"propTypes\", {\n  left: PropTypes.number.isRequired,\n  top: PropTypes.number.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  rotatable: PropTypes.bool,\n  rotateAngle: PropTypes.number,\n  parentRotateAngle: PropTypes.number,\n  zoomable: PropTypes.string,\n  minWidth: PropTypes.number,\n  minHeight: PropTypes.number,\n  aspectRatio: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),\n  onRotateStart: PropTypes.func,\n  onRotate: PropTypes.func,\n  onRotateEnd: PropTypes.func,\n  onResizeStart: PropTypes.func,\n  onResize: PropTypes.func,\n  onResizeEnd: PropTypes.func,\n  onDragStart: PropTypes.func,\n  onDrag: PropTypes.func,\n  onDragEnd: PropTypes.func\n});\n\n_defineProperty(ResizableRect, \"defaultProps\", {\n  parentRotateAngle: 0,\n  rotateAngle: 0,\n  rotatable: true,\n  zoomable: '',\n  minWidth: 10,\n  minHeight: 10\n});\n\nexport default ResizableRect;","map":null,"metadata":{},"sourceType":"module"}